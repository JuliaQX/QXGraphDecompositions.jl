var documenterSearchIndex = {"docs":
[{"location":"license/","page":"LICENSE","title":"LICENSE","text":"MIT License","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"Copyright (c) 2021 QuantEx team","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"LabeledGraph/#Labeled-Graphs","page":"Labeled Graphs","title":"Labeled Graphs","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"QXGraphDecompositions uses the SimpleGraph struct from the LightGraphs package to store  graph structures. However, some of the algorithms implemented in QXGraphDecompositions  repeatedly modify the graph they work on, either by removing or adding vertices in varying  orders, and in turn alter the manner in which vertices in the graph are indexed. This can  make it difficult to track where vertices end up in a graph after many modifications are  made, which needs to be done if the vertices are used to index different variables in an  alternate data structure, such as indices or tensors in a tensor network. To this end,  QXGraphDecompositions defines a LabeledGraph struct which pairs a SimpleGraph with and  array of julia symbols which can be used to identify vertices in a graph after modifications  have been made. ","category":"page"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"LabeledGraph","category":"page"},{"location":"LabeledGraph/#QXGraphDecompositions.LabeledGraph","page":"Labeled Graphs","title":"QXGraphDecompositions.LabeledGraph","text":"Struct to represent a labeled graph. Unique symbols are created for each vertex if none are provided and remain unaltered during the lifetime of the graph.\n\nExample\n\njulia> g = LabeledGraph()\nLabeledGraph({0, 0} undirected simple Int64 graph, Symbol[])\n\njulia> add_vertex!(g, :a_vertex_label)\n1-element Array{Symbol,1}:\n :a_vertex_label\n\njulia> g.labels[1]\n:a_vertex_label\n\n\n\n\n\n","category":"type"},{"location":"LabeledGraph/#Example-usage","page":"Labeled Graphs","title":"Example usage","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"An example of how to use LabeledGraphs is shown below. Note, whenever a modification is made to the graph which re-indexes or re-positions the vertices in the graph, the array of vertex  labels in the LabeledGraph is also updated to reflect the reordering. Hence, when a sequence of modifications is made to the graph, we can identify how the vertices of the original  graph are now indexed in the new graph by looking at how the corresponding labels are  indexed inside the LabeledGraph.","category":"page"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"using QXGraphDecompositions\n\n# Create a LabeledGraph with N vertices\nN = 10\nG = LabeledGraph(N)\n\n# Display the label assigned to the first and last vertices in the graph.\n@show G.labels[1]\n@show G.labels[end]\n\n# Remove the first vertex in the graph. To remove a vertex, LightGraphs first swaps the \n# positions of the vertex being removed and the last vertex and then removes the last vertex.\nrem_vertex!(G, 1)\n\n# Display the label which is now assigned to the first vertex in the graph.\n@show G.labels[1]","category":"page"},{"location":"LabeledGraph/#LabeledGraph-Interface","page":"Labeled Graphs","title":"LabeledGraph Interface","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"The interface for the LabeledGraph struct is intended to reflect the interface implemented  by the LightGraphs package for the SimpleGraph struct.","category":"page"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"labels\nget_vertex\nvertices\nnv\nadd_vertex!\nrem_vertex!\nedges\nne\nadd_edge!\nhas_edge\nrem_edge!\ndegree\nall_neighbors\neliminate!\ncliqueness","category":"page"},{"location":"LabeledGraph/#QXGraphDecompositions.labels","page":"Labeled Graphs","title":"QXGraphDecompositions.labels","text":"labels(G::LabeledGraph)\n\nReturn the labels contained in a LabeledGraph.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.get_vertex","page":"Labeled Graphs","title":"QXGraphDecompositions.get_vertex","text":"get_vertex(G::LabledGraph, v_label)\n\nReturn the first vertex whose label matches the argument v_label. If an array of labels is provided, an array of the corresponding vertices is return. \n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.vertices","page":"Labeled Graphs","title":"QXGraphDecompositions.vertices","text":"vertices(G::LabeledGraph)\n\nReturn the vertices of a labeled graph.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.nv","page":"Labeled Graphs","title":"QXGraphDecompositions.nv","text":"nv(G::LabeledGraph)\n\nReturn the number of vertices in G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.add_vertex!","page":"Labeled Graphs","title":"QXGraphDecompositions.add_vertex!","text":"add_vertex!(G::LabeledGraph, label::Symbol)\n\nAdd a new vertex to G and assign the given label to it.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.rem_vertex!","page":"Labeled Graphs","title":"QXGraphDecompositions.rem_vertex!","text":"rem_vertex!(G::LabeledGraph, v)\n\nDelete the vertex with index or label v from G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.edges","page":"Labeled Graphs","title":"QXGraphDecompositions.edges","text":"edges(G::LabeledGraph)\n\nReturn an iterator of the edges of G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.ne","page":"Labeled Graphs","title":"QXGraphDecompositions.ne","text":"ne(G::LabeledGraph)\n\nReturn the number of edges in G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.add_edge!","page":"Labeled Graphs","title":"QXGraphDecompositions.add_edge!","text":"add_edge!(G::LabeledGraph, u::Int, v::Int)\n\nAdd an edge to G connecting vertices u and v.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.has_edge","page":"Labeled Graphs","title":"QXGraphDecompositions.has_edge","text":"has_edge(G::LabeledGraph, u::Int, v::Int)\n\nReturn true if G has an edge connecting vertices u and v. Return false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.rem_edge!","page":"Labeled Graphs","title":"QXGraphDecompositions.rem_edge!","text":"rem_edge!(G::LabeledGraph, u::Int, v::Int)\n\nRemove the edge connecting vertices u and v if it exists.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.degree","page":"Labeled Graphs","title":"QXGraphDecompositions.degree","text":"degree(G::LabeledGraph[, v])\n\nReturn an array containing the degree of each vertex of G. If v is specified, only  return degrees for vertices in v.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.all_neighbors","page":"Labeled Graphs","title":"QXGraphDecompositions.all_neighbors","text":"all_neighbors(G::LabeledGraph, v::Int)\n\nReturn an array of all neighbors of v in G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.eliminate!","page":"Labeled Graphs","title":"QXGraphDecompositions.eliminate!","text":"eliminate!(G::LabledGraph, v)\n\nConnect all the neighbors of v together before removing v from G.\n\n\n\n\n\neliminate!(G::AbstractGraph, v::Integer)\n\nConnect all the neighbours of v together before removing v from G.\n\n\n\n\n\neliminate!(G::AbstractGraph, v::Integer, c_map::Dict{Int, Int})\n\nConnect all the neighbours of v together before removing v from G. \n\nThe dictionary c_map mapping vertices of 'G' to their cliqueness is updated inplace  accordingly.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.cliqueness","page":"Labeled Graphs","title":"QXGraphDecompositions.cliqueness","text":"cliqueness(G::LabeledGraph, v::Symbol)\n\nReturn the number of edges that need to be added to G in order to make the neighborhood of  vertex labeled by the symbol v a clique.\n\n\n\n\n\ncliqueness(G::LabeledGraph, v::Integer)\n\nReturn the number of edges that need to be added to G in order to make the neighborhood of  vertex v a clique.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#LabeledGraph-Constructors","page":"Labeled Graphs","title":"LabeledGraph Constructors","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"line_graph\ntree_from_tree_decompostion\nchordal_graph","category":"page"},{"location":"LabeledGraph/#QXGraphDecompositions.line_graph","page":"Labeled Graphs","title":"QXGraphDecompositions.line_graph","text":"line_graph(G::LabeledGraph)\n\nReturn a LabeledGraph representing the line graph of the 'G'. \n\nThe label for each each vertex of the line graph is created by concatenating the labels of  the corresponding vertices in the LabeledGraph 'G'.\n\n\n\n\n\nline_graph(G::AbstractGraph;\n           vertex_labels::Array{Symbol, 1}=Symbol[])\n\nReturn a LabeledGraph representing the line graph of the 'G'. \n\nThe label for each each vertex of the line graph is created by  concatenating the labels of the corresponding vertices in 'G'.\n\nThe symbols in the array vertex_labels are used as labels for the vertices of the returned line graph. If vertex_labels is empty then labels are created by combining the indices of  the corresponding vertices in 'G'.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.tree_from_tree_decompostion","page":"Labeled Graphs","title":"QXGraphDecompositions.tree_from_tree_decompostion","text":"tree_from_tree_decompostion(td::Dict{Symbol, Any})\n\nReturns a LabeledGraph representing the tree described by the tree decomposition in td.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.chordal_graph","page":"Labeled Graphs","title":"QXGraphDecompositions.chordal_graph","text":"chordal_graph(G::LabeledGraph, π̄::Array{Symbol, 1})\n\nReturn a chordal graph built from 'G' using the elimination order 'π̄'.\n\nThe returned graph is created from 'G' by iterating over the vertices of 'G', according to  the order 'π̄', and for each vertex, connecting all the neighbors that appear later in the  order.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#LabeledGraph-IO","page":"Labeled Graphs","title":"LabeledGraph IO","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"graph_to_gr\ngraph_to_cnf","category":"page"},{"location":"LabeledGraph/#QXGraphDecompositions.graph_to_gr","page":"Labeled Graphs","title":"QXGraphDecompositions.graph_to_gr","text":"graph_to_gr(G::LabeledGraph, filename::String)\n\nWrite the provided graph to a file in gr format.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphDecompositions.graph_to_cnf","page":"Labeled Graphs","title":"QXGraphDecompositions.graph_to_cnf","text":"graph_to_cnf(G::LabeledGraph, filename::String)\n\nWrite the provided graph to a file in cnf format.\n\n\n\n\n\n","category":"function"},{"location":"docs_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docs_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"treewidth/#Treewidth-Algorithms","page":"Treewidth","title":"Treewidth Algorithms","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"To efficiently contract a tensor network, it is essential to find an order to contract the  tensors in (which we refer to as a contraction plan) which is computationally feasible. It  was shown by Markov and Shi that a contraction plan for a network can be mapped to a tree decomposition  of the network's line graph. The computational cost of the contraction plan is then exponential in the treewidth of that tree decomposition.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"In this context, the treewidth of a tree decomposition, for a networks line graph, serves as  an indirect measure of the size of the largest intermediate tensor produced while  contracting a network according to a contraction plan that maps to the tree decompositon. As  the cost of contracting a network is dominated by contractions involing the largest  intermediate tensor, it is thus also an indirect measure of the computational cost of the  contraction plan used.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"The problem of finding a computationally feasible contraction plan for a tensor network can be solved by searching for tree decompositions, or equivalently vertex elimination orderings, that minimise the treewidth. QXGraphDecompositions provides functions for finding such tree  decompositions and vertex elimination orders.","category":"page"},{"location":"treewidth/#Tree-Decompositions","page":"Treewidth","title":"Tree Decompositions","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"An algorithm for finding tree decompositions with minimal treewidth was developed at  KIT in the group of Prof. Dorothea Wagner  is available here. QXGraphDecompositions  uses the FlowCutterPACE17_jll  wrapper package to provide the following function for computing such a tee decompostion of a graph.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"flow_cutter","category":"page"},{"location":"treewidth/#QXGraphDecompositions.flow_cutter","page":"Treewidth","title":"QXGraphDecompositions.flow_cutter","text":"flow_cutter(G::lg.AbstractGraph, time::Integer=10; seed::Integer=-1)\n\nRun the flow cutter algorithm for time seconds to find a tree decomposition for the graph  G with minimal treewidth.\n\nThe tree decomposition is returned in a dictionary with the following key value pairs:\n\n:treewidth => The treewidth of the tree decomposotion,  \n:num_bags => The number of bags in the tree decomposition,\n:num_vertices The number of vertices in G,\n:b_n => The n-th bag of the decomposition where n is an integer from 1 to the number of            bags in the decomposition. A bag is an array of vertices of G.\n:edges => An array of integer pairs indicating the edges of the tree decomposition.\n:comments => An array of comments created by flow cutter regarding heuristics used and if                it had enough time to find a decomposition.\n\nThe flow cutter algorithm and how it is used to find tree decompositions is described by Michael Hamann and Ben Strasser in the following papers: \n\nGraph Bisection with Pareto Optimization - https://dl.acm.org/doi/10.1145/3173045 Computing Tree Decompositions with FlowCutter - https://arxiv.org/abs/1709.08949\n\nKeywords\n\nseed::Integer=-1: The seed used by flow cutter. Most be a non negative integer,                     otherwise the seed is set by flow cutter.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#Vertex-Elimination-Orders","page":"Treewidth","title":"Vertex Elimination Orders","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"An equivalent strategy for finding contraction plans for tensor networks involves finding an  order in which to eliminate the vertices in the network's line graph. Here, eliminating a vertex from a graph means connecting all of its neighbours together before removing it from the graph. Vertex elimination orders can be mapped to tree decompositions and have an equivalent notion of treewidth. The treewidth of a graph, with respect to a vertex  elimination order, is the maximum number of neighbours a vertex has in the graph when it is  eliminated according the order.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"A standard algorithm for finding elimination orders, whose treewidth provides a good upper bound for the minimal treewidth of a graph, is known as the QuickBB algorithm. It was first proposed by Vibhav Gogate and Rina Dechter in their 2004 paper \"A complete  Anytime Algorithm for Treewidth\". The paper along with a binary implementation of the  algorithm is provided here.  QXGraphDecompositions provides a julia wrapper for their binary which requires a linux OS.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"quickbb","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"The min-fill heuristic is a popular heuristic for computing an upper bound on treewidth of a graph and an elimination order with the returned treewidth.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"min_fill","category":"page"},{"location":"treewidth/#QXGraphDecompositions.min_fill","page":"Treewidth","title":"QXGraphDecompositions.min_fill","text":"min_fill(G::AbstractGraph)\n\nReturns the upper bound on the tree width of G found using the min-fill heuristic. An elimination order with the returned treewidth is also returned.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"The following function can be used to recover a vertex elimination order from a tree  decomposition whose treewidth equals that of the tree decomposition. The provided tree decompositon is assumed to be contained in a dictionary similar to the one returned by the flow cutter algorithm.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"order_from_tree_decomposition","category":"page"},{"location":"treewidth/#QXGraphDecompositions.order_from_tree_decomposition","page":"Treewidth","title":"QXGraphDecompositions.order_from_tree_decomposition","text":"order_from_tree_decomposition(td::Dict{Symbol, Any}; root::Symbol=:b_1)\n\nReturn a vertex elimination order with the same treewidth as the given tree decompositon.\n\nThe algorithm used to construct the vertex elimination order is described by Shutski et al in the following paper https://doi.org/10.1103/PhysRevA.102.062614\n\nKeywords\n\nroot::Symbol=:b_1: The node of the tree to take as the root. Must be a symbol of the                      form :b_n where n is an integer between 1 and the number of bags                      in the tree decomposition.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"Given an elimination order pi for a particualr graph G, the treewidth of G with  respect to the order pi can be computed using the following function.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"find_treewidth_from_order","category":"page"},{"location":"treewidth/#QXGraphDecompositions.find_treewidth_from_order","page":"Treewidth","title":"QXGraphDecompositions.find_treewidth_from_order","text":"find_treewidth_from_order(G::LabeledGraph, π̄::Array{Symbol, 1})\n\nReturn the treewidth of G with respect to the elimination order π̄.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"The following functions can be used to create an elimination order for a graph G with a  specified clique of G appearing at the end of the order. This is useful for finding contraction plans for tensor networks containing open indices. The algorithm and application of these functions is described further by Shutski et al in this paper.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"restricted_mcs","category":"page"},{"location":"treewidth/#QXGraphDecompositions.restricted_mcs","page":"Treewidth","title":"QXGraphDecompositions.restricted_mcs","text":"restricted_mcs(H::LabeledGraph, C::Array{Symbol, 1})\n\nReturn an elimination order for the chordal graph 'H' with the vertices in 'C' appearing at  the end.\n\nIf the chordal graph H was created from an elimination order π for a graph G, the  returned elimination order for H will have a treewidth equal to that of π if C is a clique in H.\n\nThe algorithm is described by Shutski et al in https://arxiv.org/abs/1911.12242\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#Treewidth-deletion","page":"Treewidth","title":"Treewidth deletion","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"The problem of finding a select number of vertices in a graph to delete, in order to reduce the treewidth of the graph, is known as the treewidth deletion problem. A method for  solving this problem, implemented by the functions below, and it's application to tensor  network slicing is discussed by Shutski et al here.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"greedy_treewidth_deletion\ndirect_treewidth_score","category":"page"},{"location":"treewidth/#QXGraphDecompositions.greedy_treewidth_deletion","page":"Treewidth","title":"QXGraphDecompositions.greedy_treewidth_deletion","text":"greedy_treewidth_deletion(G::LabeledGraph, m::Int=4;\n                          score_function::Symbol=:degree, \n                          elim_order::Array{Symbol, 1}=[])\n\nGreedily remove vertices from G with respect to minimising the chosen score function. Return the reduced graph and an array of vertices which were removed.\n\nThe intermediate elimination orders and corresponding treewidths of the intermediate graphs are also returned if an elimination order for G is provided.\n\nThe algorithm is described by Schutski et al in Phys. Rev. A 102, 062614.\n\nKeywords\n\nscore_function::Symbol=:degree: function to maximise when selecting vertices to remove.                                   (:degree, :directtreewidth, :treetrimming)\nelim_order::Array{Symbol, 1}=Symbol[]: The elimination order for G to be used by                                           direct_treewidth score function.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#QXGraphDecompositions.direct_treewidth_score","page":"Treewidth","title":"QXGraphDecompositions.direct_treewidth_score","text":"direct_treewidth_score(G::LabeledGraph, π::Array{Symbol, 1})\n\nReturn an array of integers, one for each vertex in G, indicating the change in treewidth of G, with respect to π, if that vertex is removed.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QXGraphDecompositions","category":"page"},{"location":"#QXGraphDecompositions","page":"Home","title":"QXGraphDecompositions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QXGraphDecompositions is a Julia package for analysing and manipulating graph structures  describing tensor networks. It provides functions for solving graph theoretic problems  related to the task of efficiently slicing and contracting a tensor network.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QXGraphDecompositions was developed as part of the QuantEx project, one of the individual  software projects of WP8 of PRACE 6IP.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QXGraphDecompositions is a Julia package and can be installed using Julia's inbuilt package  manager from the Julia REPL using.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"QXGraphDecompositions\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure everything is working, the unittests can be run using","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.test()","category":"page"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An example of how QXGraphDecompositions can be used to calculate a vertex elimination order  for a graph looks like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QXGraphDecompositions\n\n# Create a LabeledGraph with N fully connected vertices.\nN = 10\nG = LabeledGraph(N)\nfor i = 1:N, j = i+1:N\n    add_edge!(G, i, j)\nend\n\n# To get an elimination order for G with minimal treewidth we call quickbb.\n# elimination_order, md = quickbb(G)\n@show elimination_order\n\n# The treewidth of the elimination order is contained in the metadata dictionary returned by \n# quickbb.\n@show md[:treewidth]","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information about the algorithms made available by QXGraphDecompositions please  consult the contents below.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Treewidth Algorithms Describes useful algorithms for analysing a tensor network's line graph.\nLabeled Graphs Describes the QXGraphDecompositions LabeledGraph struct for representing graphs.","category":"page"}]
}
