<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Treewidth · QXGraphDecompositions.jl</title><link rel="canonical" href="https://JuliaQX.github.io/QXGraphDecompositions.jl/treewidth/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QXGraphDecompositions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QXGraphDecompositions.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../LabeledGraph/">Labeled Graphs</a></li><li class="is-active"><a class="tocitem" href>Treewidth</a><ul class="internal"><li><a class="tocitem" href="#Tree-Decompositions"><span>Tree Decompositions</span></a></li><li><a class="tocitem" href="#Vertex-Elimination-Orders"><span>Vertex Elimination Orders</span></a></li><li><a class="tocitem" href="#Treewidth-deletion"><span>Treewidth deletion</span></a></li></ul></li><li><a class="tocitem" href="../docs_index/">Index</a></li><li><a class="tocitem" href="../license/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Treewidth</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Treewidth</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/master/docs/src/treewidth.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Treewidth-Algorithms"><a class="docs-heading-anchor" href="#Treewidth-Algorithms">Treewidth Algorithms</a><a id="Treewidth-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Treewidth-Algorithms" title="Permalink"></a></h1><p>To efficiently contract a tensor network, it is essential to find an order to contract the  tensors in (which we refer to as a contraction plan) which is computationally feasible. It  was shown by <a href="https://arxiv.org/abs/quant-ph/0511069">Markov and Shi</a> that a contraction plan for a network can be mapped to a <a href="https://en.wikipedia.org/wiki/Tree_decomposition">tree decomposition</a>  of the network&#39;s line graph. The computational cost of the contraction plan is then exponential in the treewidth of that tree decomposition.</p><p>In this context, the treewidth of a tree decomposition, for a networks line graph, serves as  an indirect measure of the size of the largest intermediate tensor produced while  contracting a network according to a contraction plan that maps to the tree decompositon. As  the cost of contracting a network is dominated by contractions involing the largest  intermediate tensor, it is thus also an indirect measure of the computational cost of the  contraction plan used.</p><p>The problem of finding a computationally feasible contraction plan for a tensor network can be solved by searching for tree decompositions, or equivalently vertex elimination orderings, that minimise the treewidth. QXGraphDecompositions provides functions for finding such tree  decompositions and vertex elimination orders.</p><h2 id="Tree-Decompositions"><a class="docs-heading-anchor" href="#Tree-Decompositions">Tree Decompositions</a><a id="Tree-Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Decompositions" title="Permalink"></a></h2><p>An algorithm for finding tree decompositions with minimal treewidth was developed at  <a href="https://www.kit.edu">KIT</a> in the <a href="https://i11www.iti.kit.edu">group of Prof. Dorothea Wagner</a>  is available <a href="https://github.com/kit-algo/flow-cutter-pace17">here</a>. QXGraphDecompositions  uses the <a href="https://github.com/JuliaBinaryWrappers/FlowCutterPACE17_jll.jl">FlowCutterPACE17_jll</a>  wrapper package to provide the following function for computing such a tee decompostion of a graph.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.flow_cutter" href="#QXGraphDecompositions.flow_cutter"><code>QXGraphDecompositions.flow_cutter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flow_cutter(G::lg.AbstractGraph, time::Integer=10; seed::Integer=-1)</code></pre><p>Run the flow cutter algorithm for <code>time</code> seconds to find a tree decomposition for the graph  <code>G</code> with minimal treewidth.</p><p>The tree decomposition is returned in a dictionary with the following key value pairs:</p><ul><li><code>:treewidth</code> =&gt; The treewidth of the tree decomposotion,  </li><li><code>:num_bags</code> =&gt; The number of bags in the tree decomposition,</li><li><code>:num_vertices</code> The number of vertices in <code>G</code>,</li><li><code>:b_n</code> =&gt; The n-th bag of the decomposition where n is an integer from 1 to the number of            bags in the decomposition. A bag is an array of vertices of <code>G</code>.</li><li><code>:edges</code> =&gt; An array of integer pairs indicating the edges of the tree decomposition.</li><li><code>:comments</code> =&gt; An array of comments created by flow cutter regarding heuristics used and if                it had enough time to find a decomposition.</li></ul><p>The flow cutter algorithm and how it is used to find tree decompositions is described by Michael Hamann and Ben Strasser in the following papers: </p><p>Graph Bisection with Pareto Optimization - https://dl.acm.org/doi/10.1145/3173045 Computing Tree Decompositions with FlowCutter - https://arxiv.org/abs/1709.08949</p><p><strong>Keywords</strong></p><ul><li><code>seed::Integer=-1</code>: The seed used by flow cutter. Most be a non negative integer,                     otherwise the seed is set by flow cutter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL17-L42">source</a></section></article><h2 id="Vertex-Elimination-Orders"><a class="docs-heading-anchor" href="#Vertex-Elimination-Orders">Vertex Elimination Orders</a><a id="Vertex-Elimination-Orders-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-Elimination-Orders" title="Permalink"></a></h2><p>An equivalent strategy for finding contraction plans for tensor networks involves finding an  order in which to eliminate the vertices in the network&#39;s line graph. Here, eliminating a vertex from a graph means connecting all of its neighbours together before removing it from the graph. Vertex elimination orders can be mapped to tree decompositions and have an equivalent notion of treewidth. The treewidth of a graph, with respect to a vertex  elimination order, is the maximum number of neighbours a vertex has in the graph when it is  eliminated according the order.</p><p>A standard algorithm for finding elimination orders, whose treewidth provides a good upper bound for the minimal treewidth of a graph, is known as the QuickBB algorithm. It was first proposed by Vibhav Gogate and Rina Dechter in their 2004 paper &quot;A complete  Anytime Algorithm for Treewidth&quot;. The paper along with a binary implementation of the  algorithm is provided <a href="http://www.hlt.utdallas.edu/~vgogate/quickbb.html">here</a>.  QXGraphDecompositions provides a julia wrapper for their binary which requires a linux OS.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.quickbb" href="#QXGraphDecompositions.quickbb"><code>QXGraphDecompositions.quickbb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quickbb(G::lg.AbstractGraph; 
        time::Integer=0, 
        order::Symbol=:_, 
        verbose::Bool=false )::Tuple{Int, Array{Int, 1}}</code></pre><p>Call Gogate&#39;s QuickBB binary on the provided graph and return the resulting perfect  elimination ordering. </p><p>A dictionary containing metadata for the elimination order is also returned. Metadata includes: </p><ul><li><code>:treewidth</code> of the elimination order,  </li><li><code>:time</code> taken by quickbb to find the order,</li><li><code>:lowerbound</code> for the treewidth computed by quickbb,</li><li><code>:is_optimal</code> a boolean indicating if the order as optiaml treewidth.</li></ul><p>The QuickBB algorithm is described in arXiv:1207.4109v1</p><p><strong>Keywords</strong></p><ul><li><code>time::Integer=0</code>: the number of second to run the quickbb binary for.</li><li><code>order::Symbol=:_</code>: the branching order to be used by quickbb (:random or :min_fill).</li><li><code>lb::Bool=false</code>: set if a lowerbound for the treewidth should be computed.</li><li><code>verbose::Bool=false</code>: set to true to print quickbb stdout and stderr output.</li><li><code>proc_id::Integer=0</code>: used to create uniques names of files for different processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL342-L366">source</a></section></article><p>The min-fill heuristic is a popular heuristic for computing an upper bound on treewidth of a graph and an elimination order with the returned treewidth.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.min_fill" href="#QXGraphDecompositions.min_fill"><code>QXGraphDecompositions.min_fill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">min_fill(G::AbstractGraph)</code></pre><p>Returns the upper bound on the tree width of <code>G</code> found using the min-fill heuristic. An elimination order with the returned treewidth is also returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL98-L103">source</a></section></article><p>The following function can be used to recover a vertex elimination order from a tree  decomposition whose treewidth equals that of the tree decomposition. The provided tree decompositon is assumed to be contained in a dictionary similar to the one returned by the flow cutter algorithm.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.order_from_tree_decomposition" href="#QXGraphDecompositions.order_from_tree_decomposition"><code>QXGraphDecompositions.order_from_tree_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">order_from_tree_decomposition(td::Dict{Symbol, Any}; root::Symbol=:b_1)</code></pre><p>Return a vertex elimination order with the same treewidth as the given tree decompositon.</p><p>The alogithm used to construct the vertex elimination order is described by Shutski et al in the following paper https://doi.org/10.1103/PhysRevA.102.062614</p><p><strong>Keywords</strong></p><ul><li><code>root::Symbol=:b_1</code>: The node of the tree to take as the root. Must be a symbol of the                      form <code>:b_n</code> where <code>n</code> is an integer between 1 and the number of bags                      in the tree decomposition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL124-L136">source</a></section></article><p>Given an elimination order <span>$\pi$</span> for a particualr graph <span>$G$</span>, the treewidth of <span>$G$</span> with  respect to the order <span>$\pi$</span> can be computed using the following function.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.find_treewidth_from_order" href="#QXGraphDecompositions.find_treewidth_from_order"><code>QXGraphDecompositions.find_treewidth_from_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_treewidth_from_order(G::LabeledGraph, π̄::Array{Symbol, 1})</code></pre><p>Return the treewidth of <code>G</code> with respect to the elimination order <code>π̄</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL218-L222">source</a></section></article><p>The following functions can be used to create an elimination order for a graph <span>$G$</span> with a  specified clique of <span>$G$</span> appearing at the end of the order. This is useful for finding contraction plans for tensor networks containing open indices. The algorithm and application of these functions is described further by Shutski et al in <a href="https://arxiv.org/abs/1911.12242">this</a> paper.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.restricted_mcs" href="#QXGraphDecompositions.restricted_mcs"><code>QXGraphDecompositions.restricted_mcs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">restricted_mcs(H::LabeledGraph, C::Array{Symbol, 1})</code></pre><p>Return an elimination order for the chordal graph &#39;H&#39; with the vertices in &#39;C&#39; appearing at  the end.</p><p>If the chordal graph <code>H</code> was created from an elimination order π for a graph <code>G</code>, the  returned elimination order for <code>H</code> will have a treewidth equal to that of π if <code>C</code> is a clique in <code>H</code>.</p><p>The algorithm is described by Shutski et al in https://arxiv.org/abs/1911.12242</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL174-L185">source</a></section></article><h2 id="Treewidth-deletion"><a class="docs-heading-anchor" href="#Treewidth-deletion">Treewidth deletion</a><a id="Treewidth-deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Treewidth-deletion" title="Permalink"></a></h2><p>The problem of finding a select number of vertices in a graph to delete, in order to reduce the treewidth of the graph, is known as the treewidth deletion problem. A method for  solving this problem, implemented by the functions below, and it&#39;s application to tensor  network slicing is discussed by Shutski et al <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.062614">here</a>.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.greedy_treewidth_deletion" href="#QXGraphDecompositions.greedy_treewidth_deletion"><code>QXGraphDecompositions.greedy_treewidth_deletion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">greedy_treewidth_deletion(G::LabeledGraph, m::Int=4;
                          score_function::Symbol=:degree, 
                          π::Array{Symbol, 1}=[])</code></pre><p>Greedily remove vertices from G with respect to minimising the chosen score function. Return the reduced graph and an array of vertices which were removed.</p><p>The intermediate elimination orders and corresponding treewidths of the intermediate graphs are also returned if an elimination order for G is provided.</p><p>The algorithm is described by Schutski et al in Phys. Rev. A 102, 062614.</p><p><strong>Keywords</strong></p><ul><li><code>score_function::Symbol=:degree</code>: function to maximise when selecting vertices to remove.                                   (:degree, :direct_treewidth)</li><li><code>elim_order:Array{Symbol, 1}=Symbol[]</code>: The elimination order for G to be used by                                          direct_treewidth score function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL245-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXGraphDecompositions.direct_treewidth_score" href="#QXGraphDecompositions.direct_treewidth_score"><code>QXGraphDecompositions.direct_treewidth_score</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">direct_treewidth_score(G::LabeledGraph, π::Array{Symbol, 1})</code></pre><p>Return an array of integers, one for each vertex in G, indicating the change in treewidth of G, with respect to π, if that vertex is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraphDecompositions.jl/blob/a030c09c1b348cf857eb6ddb1742ae307e8d4089/src/treewidth.jl#LL310-L315">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LabeledGraph/">« Labeled Graphs</a><a class="docs-footer-nextpage" href="../docs_index/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 14 April 2021 22:32">Wednesday 14 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
